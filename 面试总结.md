# 一、JS

## 1.1、内置类型

1. 7种内置类型，两大类：基本数据类型和复杂数据类型
2. `number`是浮点类型，没有整型，基于**IEEE 754**标准
3. NaN的数据类型是`number`，并且NaN ！= NaN

## 1.2、Typeof

1、基本数据类型的`typeof`

```js
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof b // b 没有声明，但是还会显示 undefined
```

2、复杂数据类型的`typeof`

```js
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```

3、null的`typeof`

```js
typeof null // 'object'
```

null的数据类型是object是JS的一个bug，原因是JS最初版本中，使用的是32位系统，为了性能考虑，使用**低位存储了变量的类型信息，`000`开头的代表对象，而`null`表示全位0**，所以错误判断为`object`

4、正确的判断方式`Object.prototype.toString.call()`

```js
通过这种方式可以得到[Object Type]的字符串
```

5、低版本undefined处理

```js
let a
// 我们也可以这样判断 undefined
a === undefined
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值
let undefined = 1
// 这样判断就会出错
// 所以可以用下面的方式来判断，并且代码量更少
// 因为 void 后面随便跟上一个组成表达式
// 返回就是 undefined
a === void 0
```

## 1.3、类型转换

### 1.3.1、 转成boolean类型

在条件判断时，除了 `undefined`， `null`， `false`， `NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象。

### 1.3.2、对象转基本类型

对象在转换基本类型时，首先会调用 `valueOf` 然后调用 `toString`。并且这两个方法你是可以重写的。

1、`valueOf`返回值为该对象的原始值

2、`null`和`undefined`不能转换成字符串，调用toString()方法会报错

3、**Symbol.toPrimitive**，该方法在转基本类型时调用优先级最高。

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
  [Symbol.toPrimitive]() {
    return 2;
  }
}
1 + a // => 3
'1' + a // => '12'
```

### 1.3.3、四则运算符

1、加法运算

其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。

```js
1 + '1' // '11'
2 * '2' // 4
[1, 2] + [2, 1] // '1,22,1'
// [1, 2].toString() -> '1,2'
// [2, 1].toString() -> '2,1'
// '1,2' + '2,1' = '1,22,1'
```

对于加号需要注意这个表达式 `'a' + + 'b'`

```js
'a' + + 'b' // -> "aNaN"
// 因为 + 'b' -> NaN
// 你也许在一些代码中看到过 + '1' -> 1
```

### 1.3.4、== 操作符

![==操作符](./interviewImg/==操作符.png)

```js
[] == ![] 为true过程解析

//!的优先级最高，先执行取反操作
[] == false
// 根据第 8 条得出
[] == ToNumber(false)
[] == 0
// 根据第 10 条得出
ToPrimitive([]) == 0
// [].toString() -> ''
'' == 0
// 根据第 6 条得出
0 == 0 // -> true
```

### 1.3.5、比较运算符

1. 如果是对象，就通过 `toPrimitive` 转换对象
2. 如果是字符串，就通过 `unicode` 字符索引来比较

## 1.4、原型

1. 每个函数都有 `prototype` 属性，除了 `Function.prototype.bind()`，该属性指向原型。
2. 每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 `[[prototype]]`，但是 `[[prototype]]` 是内部属性，我们并不能访问到，所以使用 `_proto_` 来访问。

## 1.5、new

1. 首先创建一个空的对象，空对象的__proto__属性指向构造函数的原型
2. 把上面创建的空对象赋值构造函数内部的this，用构造函数内部的方法修改空对象
3. 如果构造函数返回一个非引用类型的值，则返回这个值，否则上面创建的对象

根据上面的4个功能，我们来实现一个`new`

```js
function _new(constructor, ...arg){
    // 创建新对象链接原型链
    const obj = Object.create(constructor.prototype)
    // 绑定this
    const res = constructor.apply(obj,arg)
    // 返回新对象
    return res instanceof Object? res: obj
}
```

## 1.6、instanceOf

`instanceof` 可以正确的判断对象的构造函数类型，

因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

```js
function instanceOf(instance,constructor){
   // 获取实例的原型
    let instancePrototype = instance.__proto__
    // 获取构造函数原型
    let	constructorPrototype = constructor.prototype
    while(true){
        if(instancePrototype === null) return false
        if(instancePrototype === constructorPrototype) return true
        instancePrototype = instancePrototype.__proto__
    }
}	
```

## 1.7、this

```js
function foo() {
	console.log(this.a)
}
var a = 1
foo()

var obj = {
	a: 2,
	foo: foo
}
obj.foo()

// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况

// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
var c = new foo()
c.a = 3
console.log(c.a)

// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new
```

```js
function a() {
    return () => {
        return () => {
        	console.log(this)
        }
    }
}
console.log(a()()())
```

箭头函数其实是没有 `this` 的，这个函数中的 `this` 只取决于他外面的第一个不是箭头函数的函数的 `this`。在这个例子中，因为调用 `a` 符合前面代码中的第一个情况，所以 `this` 是 `window`。并且 `this` 一旦绑定了上下文，就不会被任何代码改变。

## 1.8、执行上下文（作用域）

当执行 JS 代码时，会产生三种执行上下文

- 全局执行上下文
- 函数执行上下文
- eval 执行上下文

每个执行上下文中都有三个重要的属性

- 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问
- 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）
- this

## 1.9、闭包

函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

## 1.10、深浅拷贝

### 1.10.1、浅拷贝

首先可以通过 `Object.assign` 和`...`来解决这个问题。

```js
// 第一种方式
let a = { age: 1 }
let b = Object.assign({},a)
a.age = 2 
console.log(b.age) // 1

// 第二种方式
let a = { age: 1 }
let b = {...a}
a.age = 2 
console.log(b.age) // 1
```

### 1.10.2、深拷贝

想要修改对象内部对象的值时，可以通过 `JSON.parse(JSON.stringify(object))` 来解决。

```js
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

但是该方法也是有局限性的：

- 会忽略 `undefined`
- 会忽略 `symbol`
- 不能序列化函数
- 不能解决循环引用的对象

**可以使用lodash的_clonedeep [lodash 的深拷贝函数](https://lodash.com/docs##cloneDeep)**

## 1.11、防抖

**触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间**

你是否在日常开发中遇到一个问题，在**滚动事件中需要做个复杂计算**或者实现一个**按钮的防二次点击操作**。

这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。

- 例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用`延迟执行`的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。
- 例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用`立即执行`的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。

**防抖函数实现思路**

- 对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 `null`，就可以再次点击了。
- 对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数

```js
//	获取当前时间戳
function now(){
    return +new Date()
}
/*
	@param	{function}	cb			回调函数
    @param 	{number}	wait		间隔时间
    @param	{boolean}	immediate	执行方式，true为立即执行
    @return	{function}
*/

function  debounce(cb,wait = 50, immediate = true){
    let timer,ctx,args
    
    //	延迟执行
    const later = () => setTimeout(()=>{
        // 清空定时器
        timer = null
        //	执行回调，重置缓存中ctx，args
        if(!immediate){
            cb.apply(ctx, args)
            ctx = args = null
        }
    },wait)
    //	立即执行
    return function(...params){
        //	判断定时器是否存在
        if(!timer){
            //	不存在创建
            timer = later()
            //	判断是否立即执行
            if(immediate){
                cb.apply(this,params)
            }else{
                //	非立即执行，参数存入缓存ctx，args
                ctx = this
                args = params
            }
        }else{
            //	存在，清空重建
            clearTimeout(timer)
            timer = later()
        }
    }
}
```

## 1.12、节流

高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率



