## 名词解析

ECStack			=>	执行上下文环境栈

EC					 =>	执行上下文

EC（G）		   =>	全局对象（EC Global）,浏览器中赋值给window

AO					=>	活动变量对象（可以理解为函数的变量对象，length为形参个数）

VO					=>	全局（EC（G））的变量对象

进栈				  =>	执行上下文压缩入栈（1、初始化实参集合	2、创建形参变量并赋值）

​								  注意：1、非严格模式下，实参集合和形参变量存在映射机制	

​											  2、ES6箭头函数中没有arguments实参集合

出栈				  =>	EC执行完毕无用的移出栈

压栈				  =>	EC执行完毕存在作用的压入栈底

## 1、浏览器代码解析全过程

编译器

​		词法解析

​		AST抽象语法树

引擎（V8）

​		变量提升

​		作用域	/	闭包

​		变量对象

​		堆栈内存

​		GO/VO/AO

### 2、作用域图解

![](C:\Users\Administrator\Desktop\interview\knowledgeImg\2.作用域链.png)

# JS高级

### 1、单例设计模式

```
let singletonPattern = ~ function () {
	method1(){},
	method2(){}
	
	return {
		method1,
		method2
	}
}()

// 使用
singletonPattern.method1()
```

### 2、惰性函数

```js
function emit(element, type, func) {
    if (element.addEventListener) {
        emit = function (element, type, func) {
            element.addEventListener(type, func, false);
        };
    } else if (element.attachEvent) {
        emit = function (element, type, func) {
            element.attachEvent('on' + type, func);
        };
    } else {
        emit = function (element, type, func) {
            element['on' + type] = func;
        };
    }
    emit(element, type, func);
}
```

### 3、柯理化函数

```js
~function(proto){
    function bind(context=window,...outerArgs){
        let _this=this;
        return function(...innerArgs){
            let args=outerArgs.concat(innerArgs);
            _this.call(context,...args);
        }
    }
    proto.bind = bind;
}(Function.prototype);

```

### 4、compose函数（扁平化函数）

```js
 let fn1 = function (x) {
     return x + 10;
 };
let fn2 = function (x) {
    return x * 10;
};
let fn3 = function (x) {
    return x / 10;
};

// fn3(fn1(fn2(fn1(5))))
//=>compose函数调用的扁平化
console.log(compose()(5)); //=>5
console.log(compose(fn1)(5)); //=>5+10 = 15
console.log(compose(fn1,fn2)(5));//=>fn1(5)=15  fn2(15)=150 ...
console.log(compose(fn1, fn2, fn1, fn3)(5)); //=>16


function compose(...funcs) {
    if(funcs.length === 0){
        return arg => arg
    }
    if(funcs.length === 1){
        return funcs[0]
    }

    return funcs.reduce((a,b) => (...args) => b(a(...args)))
}
```

